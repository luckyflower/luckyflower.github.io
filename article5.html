<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
##**CSS3 animation-timing-function 属性值steps()函数详解**

###**1、CSS3 animation**
首先我们先回顾一下CSS3 animation的各个属性及其值：
```css
animation: name duration timing-function delay iteration-count direction;
```
<table border="1">
  <tr>
    <th>属性  </th>
    <th>描述</th>
    <th>值 </th>
  </tr>
  <tr>
    <td>name</td>
    <td>名称</td>
    <td>name</td>
  </tr>
<tr>
    <td>duration</td>
    <td>花费时间</td>
    <td>xs</td>
  </tr>
<tr>
    <td>timing-function</td>
    <td>速度曲线</td>
    <td>（写在下个表格中）</td>
  </tr>
<tr>
    <td>delay</td>
    <td>延迟</td>
    <td>xs</td>
  </tr>
<tr>
    <td>iteration-count</td>
    <td>次数</td>
    <td> n / 无限次infinite</td>
  </tr>
<tr>
    <td>direction</td>
    <td>是否反向</td>
    <td>normal / 反向alternate</td>
  </tr>
</table>

###**2、animation-timing-function**
接下来分析`animation-timing-function`的各个属性值：
<table border="1">
  <tr>
    <th>值</th>
    <th>描述</th>
  </tr>
  <tr>
    <td>linear</td>
    <td>匀速</td>
  </tr>
<tr>
    <td>ease </td>
    <td>缓进缓出</td>
  </tr>
<tr>
    <td>ease-in</td>
    <td>缓进</td>
  </tr>
<tr>
    <td>ease-out</td>
    <td>缓出</td>
  </tr>
<tr>
    <td>ease-in-out</td>
    <td> 缓进缓出</td>
  </tr>
<tr>
    <td>cubic-bezier(n,n,n,n)</td>
    <td>cubic-bezier()自定义速度模式</td>
  </tr>
<tr>
    <td>steps(n,[start/end])</td>
    <td>分步过渡函数</td>
  </tr>
<tr>
    <td>steps-start</td>
    <td>相当于(1,start)</td>
  </tr>
<tr>
    <td>steps-end</td>
    <td>相当于(1,end)</td>
  </tr>
</table>

###**3、平滑过渡模式&&分步过渡函数**
如表格所示，前面几个值我们都比较熟悉，这些值及函数可以称为**平滑过渡模式**，那什么是**平滑过渡模式**呢？**`steps()`**是什么呢？什么叫做**分步过渡函数**呢？

首先我们先来看看平滑过渡模式的例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#a" target="_blank">平滑过渡模式</a>

接下来再看看分步过渡模式的例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#b" target="_blank">分步过渡模式</a>

由上面两个例子可以看出，平滑过渡模式是很流畅的过渡，而分步过渡模式则是一帧一帧的过渡。

那这样有什么好处呢？
我们可以根据不同的过渡模式，在不同的场景下运用，
可见下面这个DEMO：

<a href="http://designmodo.com/demo/stepscss/index.html" target="_blank">DEMO</a>

###**4、steps(n,[start/end])**
再来分析一下，steps()是怎么使用的呢？

首先我们来分析一下`steps(n,[start/end])`这个属性值。
其有两个参数，第二个参数是可选的，默认为 end，具体描述如下表：
<table border="1">
  <tr>
    <th>值</th>
    <th>描述</th>
  </tr>
  <tr>
    <td>n</td>
    <td>为大于0的整数，将动画等分成指定数目的小间隔动画</td>
  </tr>
<tr>
    <td>start </td>
    <td> 以下一帧的显示效果来填充间隔动画</td>
  </tr>
<tr>
    <td>end </td>
    <td>与start相反，是以上一帧的显示效果来填充间隔动画</td>
  </tr>
<tr>
</table>
###**5，steps(n)**
接下来看看具体例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#c" target="_blank">steps(n)</a>

这上面两个例子的animation-timing-function值都为steps(2)，不是把动画分为两步吗？为什么一个走了两步，一个八步呢？
别着急，让我们来看看它的动画：
```
//走了两步的动画
@keyframes mymove{
	from {width:500px;}
	to {width:800px;}
}
```
```
//走了八步的动画
@keyframes mymove1{
	0%{width:500px;}
	20%{width:600px;}
	40%{width:700px;}
	60%{width:750px;}
	100%{width:800px;}
}
```
这样子看应该就很清楚了，steps(n)函数，n并不是把整个动画分为n步完成，而是变化的节点间的动画分为n步。

###**6、steps(n,start) && steps(n,end)**
首先还是看一下例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#d" target="_blank">steps(n,start) && steps(n,end)</a>

可以看出，steps(2,start)与steps(2,end)并不在同个起点出发，
定义了start参数的话，元素在初始化的时候就设置为了分隔出来步数的第一步的状态。

也就是说，如果这个动画被分为八步，设置start属性了的，一开始就会在第一步，由第一步过渡至第二步；而end，会在初始状态向第一步过渡，再向第二步……

下图可以帮助你理解得更加透彻：
 ![](http://luckyflower.github.io/img/start_end.gif)
 ![](http://luckyflower.github.io/img/steps-start-end.jpg)

###**7、steps-start && steps-end**
之前的属性我们说了，

steps-start就相当于steps(1,start)，
steps-end就相当于steps(1,end); 
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="css3animationtimingfunctionsteps"><strong>CSS3 animation-timing-function 属性值steps()函数详解</strong></h2>

<h3 id="1css3animation"><strong>1、CSS3 animation</strong></h3>

<p>首先我们先回顾一下CSS3 animation的各个属性及其值：</p>

<pre><code class="css">animation: name duration timing-function delay iteration-count direction;
</code></pre>

<table border="1">
  <tbody><tr>
    <th>属性  </th>
    <th>描述</th>
    <th>值 </th>
  </tr>
  <tr>
    <td>name</td>
    <td>名称</td>
    <td>name</td>
  </tr>
<tr>
    <td>duration</td>
    <td>花费时间</td>
    <td>xs</td>
  </tr>
<tr>
    <td>timing-function</td>
    <td>速度曲线</td>
    <td>（写在下个表格中）</td>
  </tr>
<tr>
    <td>delay</td>
    <td>延迟</td>
    <td>xs</td>
  </tr>
<tr>
    <td>iteration-count</td>
    <td>次数</td>
    <td> n / 无限次infinite</td>
  </tr>
<tr>
    <td>direction</td>
    <td>是否反向</td>
    <td>normal / 反向alternate</td>
  </tr>
</tbody></table>

<h3 id="2animationtimingfunction"><strong>2、animation-timing-function</strong></h3>

<p>接下来分析<code>animation-timing-function</code>的各个属性值：</p>

<table border="1">
  <tbody><tr>
    <th>值</th>
    <th>描述</th>
  </tr>
  <tr>
    <td>linear</td>
    <td>匀速</td>
  </tr>
<tr>
    <td>ease </td>
    <td>缓进缓出</td>
  </tr>
<tr>
    <td>ease-in</td>
    <td>缓进</td>
  </tr>
<tr>
    <td>ease-out</td>
    <td>缓出</td>
  </tr>
<tr>
    <td>ease-in-out</td>
    <td> 缓进缓出</td>
  </tr>
<tr>
    <td>cubic-bezier(n,n,n,n)</td>
    <td>cubic-bezier()自定义速度模式</td>
  </tr>
<tr>
    <td>steps(n,[start/end])</td>
    <td>分步过渡函数</td>
  </tr>
<tr>
    <td>steps-start</td>
    <td>相当于(1,start)</td>
  </tr>
<tr>
    <td>steps-end</td>
    <td>相当于(1,end)</td>
  </tr>
</tbody></table>

<h3 id="3"><strong>3、平滑过渡模式&amp;&amp;分步过渡函数</strong></h3>

<p>如表格所示，前面几个值我们都比较熟悉，这些值及函数可以称为<strong>平滑过渡模式</strong>，那什么是<strong>平滑过渡模式</strong>呢？<strong><code>steps()</code></strong>是什么呢？什么叫做<strong>分步过渡函数</strong>呢？</p>

<p>首先我们先来看看平滑过渡模式的例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#a" target="_blank">平滑过渡模式</a></p>

<p>接下来再看看分步过渡模式的例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#b" target="_blank">分步过渡模式</a></p>

<p>由上面两个例子可以看出，平滑过渡模式是很流畅的过渡，而分步过渡模式则是一帧一帧的过渡。</p>

<p>那这样有什么好处呢？
我们可以根据不同的过渡模式，在不同的场景下运用，
可见下面这个DEMO：</p>

<p><a href="http://designmodo.com/demo/stepscss/index.html" target="_blank">DEMO</a></p>

<h3 id="4stepsnstartend"><strong>4、steps(n,[start/end])</strong></h3>

<p>再来分析一下，steps()是怎么使用的呢？</p>

<p>首先我们来分析一下<code>steps(n,[start/end])</code>这个属性值。
其有两个参数，第二个参数是可选的，默认为 end，具体描述如下表：</p>

<table border="1">
  <tbody><tr>
    <th>值</th>
    <th>描述</th>
  </tr>
  <tr>
    <td>n</td>
    <td>为大于0的整数，将动画等分成指定数目的小间隔动画</td>
  </tr>
<tr>
    <td>start </td>
    <td> 以下一帧的显示效果来填充间隔动画</td>
  </tr>
<tr>
    <td>end </td>
    <td>与start相反，是以上一帧的显示效果来填充间隔动画</td>
  </tr>
<tr>
</tr></tbody></table>

<h3 id="5stepsn"><strong>5，steps(n)</strong></h3>

<p>接下来看看具体例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#c" target="_blank">steps(n)</a></p>

<p>这上面两个例子的animation-timing-function值都为steps(2)，不是把动画分为两步吗？为什么一个走了两步，一个八步呢？
别着急，让我们来看看它的动画：</p>

<pre><code>//走了两步的动画
@keyframes mymove{
    from {width:500px;}
    to {width:800px;}
}
</code></pre>

<pre><code>//走了八步的动画
@keyframes mymove1{
    0%{width:500px;}
    20%{width:600px;}
    40%{width:700px;}
    60%{width:750px;}
    100%{width:800px;}
}
</code></pre>

<p>这样子看应该就很清楚了，steps(n)函数，n并不是把整个动画分为n步完成，而是变化的节点间的动画分为n步。</p>

<h3 id="6stepsnstartstepsnend"><strong>6、steps(n,start) &amp;&amp; steps(n,end)</strong></h3>

<p>首先还是看一下例子：<a href="http://htmlpreview.github.com/?https://github.com/luckyflower/example/blob/master/animation.html#d" target="_blank">steps(n,start) &amp;&amp; steps(n,end)</a></p>

<p>可以看出，steps(2,start)与steps(2,end)并不在同个起点出发，
定义了start参数的话，元素在初始化的时候就设置为了分隔出来步数的第一步的状态。</p>

<p>也就是说，如果这个动画被分为八步，设置start属性了的，一开始就会在第一步，由第一步过渡至第二步；而end，会在初始状态向第一步过渡，再向第二步……</p>

<p>下图可以帮助你理解得更加透彻：
 <img src="http://luckyflower.github.io/img/start_end.gif" alt="" title="">
 <img src="http://luckyflower.github.io/img/steps-start-end.jpg" alt="" title=""></p>

<h3 id="7stepsstartstepsend"><strong>7、steps-start &amp;&amp; steps-end</strong></h3>

<p>之前的属性我们说了，</p>

<p>steps-start就相当于steps(1,start)，
steps-end就相当于steps(1,end); </p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "article5.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
